
########################################################################################
# File       : parser.py
# Author     : Devin Arena
# Description: Parses tokens generated by the lexer.
# Since      : 5/4/2022
########################################################################################

import trees.expr
import trees.statement
import errors
import token
import tokens
import oof

class Parser:

    def __init__(self, tokens) -> None:
        self.tokens = tokens
        self.current = 0
    
    def parse(self) -> list:
        statements = []

        while not self.at_end():
            statements.append(self.declaration())
        
        return statements
    
    def declaration(self) -> trees.statement.Statement:
        try:
            if self.match([tokens.FUN]):
                return self.function("function")
            if self.match([tokens.SET]):
                return self.set_declaration()
            
            return self.statement()
        except errors.ParseError as e:
            self.synchronize()
            return None
        
    def function(self, kind) -> trees.statement.Statement:
        name = self.consume([tokens.IDENTIFIER], f"Expect {kind} name.")

        self.consume([tokens.LEFT_PAREN], f"Expect '(' after {kind} name.")
        parameters = []
        if not self.check([tokens.RIGHT_PAREN]):
            if len(parameters) >= 255:
                self.error(self.peek(), "Cannot have more than 255 parameters.")
            parameters.append(self.consume([tokens.IDENTIFIER], "Expect parameter name."))

            while self.match([tokens.COMMA]):
                if len(parameters) >= 255:
                    self.error(self.peek(), "Cannot have more than 255 parameters.")

                parameters.append(self.consume([tokens.IDENTIFIER], "Expect parameter name."))
        
        self.consume([tokens.RIGHT_PAREN], "Expect ')' after parameters.")

        self.consume([tokens.LEFT_BRACE], "Expect '{' before function body.")
        body = self.block()

        return trees.statement.Function(name, parameters, body)
        
    def set_declaration(self) -> trees.statement.Statement:
        name = self.consume([tokens.IDENTIFIER], "Expect variable name.")
        initializer = None
        if self.match([tokens.EQUAL]):
            initializer = self.expression()
        self.consume([tokens.SEMI_COLON], "Expect ';' after variable declaration.")
        return trees.statement.Set(name, initializer)
    
    def statement(self) -> trees.statement.Statement:
        if self.match([tokens.FOR]):
            return self.for_statement()
        if self.match([tokens.IF]):
            return self.if_statement()
        if self.match([tokens.OUTPUT]):
            return self.output_statement()
        if self.match([tokens.WHILE]):
            return self.while_statement()
        if self.match([tokens.LEFT_BRACE]):
            return trees.statement.Block(self.block())
        
        return self.expression_statement()
    
    def for_statement(self) -> trees.statement.Statement:
        self.consume([tokens.LEFT_PAREN], "Expect '(' after 'for'.")

        initializer = None
        if self.match([tokens.SEMI_COLON]):
            initializer = None
        elif self.match([tokens.SET]):
            initializer = self.set_declaration()
        else:
            initializer = self.expression_statement()

        condition = None
        if not self.check([tokens.SEMI_COLON]):
            condition = self.expression()
        self.consume([tokens.SEMI_COLON], "Expect ';' after condition.")

        increment = None
        if not self.check([tokens.RIGHT_PAREN]):
            increment = self.expression()
        self.consume([tokens.RIGHT_PAREN], "Expect ')' after increment.")

        body = self.statement()

        if increment:
            body = trees.statement.Block([body, trees.statement.Expression(increment)])
        
        if not condition:
            condition = False
        body = trees.statement.While_(condition, body)

        if initializer:
            body = trees.statement.Block([initializer, body])

        return body
    
    def if_statement(self) -> trees.statement.Statement:
        self.consume([tokens.LEFT_PAREN], "Expect '(' after 'if'.")
        condition = self.expression()
        self.consume([tokens.RIGHT_PAREN], "Expect ')' after condition.")

        then_branch = self.statement()
        else_branch = None
        if self.match([tokens.ELSE]):
            else_branch = self.statement()

        return trees.statement.If_(condition, then_branch, else_branch)
    
    def output_statement(self) -> trees.statement.Statement:
        value = self.expression()
        self.consume([tokens.SEMI_COLON], "Expect ';' after value.")
        return trees.statement.Output(value)
    
    def while_statement(self) -> trees.statement.Statement:
        self.consume([tokens.LEFT_PAREN], "Expect '(' after 'while'.")
        condition = self.expression()
        self.consume([tokens.RIGHT_PAREN], "Expect ')' after condition.")
        body = self.statement()

        return trees.statement.While_(condition, body)
    
    def block(self) -> list:
        statements = []

        while not self.check([tokens.RIGHT_BRACE]) and not self.at_end():
            statements.append(self.declaration())

        self.consume([tokens.RIGHT_BRACE], "Expect '}' after block.")
        return statements
    
    def expression_statement(self) -> trees.statement.Statement:
        expr = self.expression()
        self.consume([tokens.SEMI_COLON], "Expect ';' after expression.")
        return trees.statement.Expression(expr)

    def expression(self) -> trees.expr.Expr:
        return self.assignment()
    
    def assignment(self) -> trees.expr.Expr:
        expr = self.or_exp()

        if self.match([tokens.EQUAL]):
            operator = self.previous()
            value = self.assignment()

            if type(expr) is trees.expr.Variable:
                return trees.expr.Assign(expr.name, value)
            
            raise self.error(operator, "Invalid assignment target.")

        return expr
    
    def or_exp(self) -> trees.expr.Expr:
        expr = self.and_exp()

        while self.match([tokens.OR]):
            operator = self.previous()
            right = self.and_exp()
            expr = trees.expr.Logical(expr, operator, right)
        
        return expr
    
    def and_exp(self) -> trees.expr.Expr:
        expr = self.equality()

        while self.match([tokens.AND]):
            operator = self.previous()
            right = self.equality()
            expr = trees.expr.Logical(expr, operator, right)
        
        return expr
    
    def equality(self) -> trees.expr.Expr:
        expr = self.comparison()

        while self.match([tokens.BANG_EQUAL, tokens.EQUAL_EQUAL]):
            operator = self.previous()
            right = self.comparison()
            expr = trees.expr.Binary(expr, operator, right)

        return expr
    
    def comparison(self) -> trees.expr.Expr:
        expr = self.term()

        while self.match([tokens.GREATER, tokens.GREATER_EQUAL, tokens.LESS, tokens.LESS_EQUAL]):
            operator = self.previous()
            right = self.term()
            expr = trees.expr.Binary(expr, operator, right)

        return expr
    
    def term(self) -> trees.expr.Expr:
        expr = self.factor()

        while self.match([tokens.PLUS, tokens.MINUS]):
            operator = self.previous()
            right = self.factor()
            expr = trees.expr.Binary(expr, operator, right)

        return expr
    
    def factor(self) -> trees.expr.Expr:
        expr = self.unary()

        while self.match([tokens.SLASH, tokens.STAR]):
            operator = self.previous()
            right = self.unary()
            expr = trees.expr.Binary(expr, operator, right)
        
        return expr
    
    def unary(self) -> trees.expr.Expr:
        if self.match([tokens.BANG, tokens.MINUS]):
            operator = self.previous()
            right = self.unary()
            return trees.expr.Unary(operator, right)
        return self.call()
    
    def call(self) -> trees.expr.Expr:
        expr = self.primary()

        while True:
            if self.match([tokens.LEFT_PAREN]):
                expr = self.finish_call(expr)
            else:
                break
        
        return expr
    
    def finish_call(self, callee: trees.expr.Expr) -> trees.expr.Expr:
        arguments = []

        if not self.check([tokens.RIGHT_PAREN]):
            arguments.append(self.expression())

            while self.match([tokens.COMMA]):
                if len(arguments) >= 255:
                    self.error(self.peek(), "Cannot have more than 255 arguments.")
                arguments.append(self.expression())
        
        paren = self.consume([tokens.RIGHT_PAREN], "Expect ')' after arguments.")

        return trees.expr.Call(callee, paren, arguments)

    def primary(self) -> trees.expr.Expr:
        if self.match([tokens.FALSE]):
            return trees.expr.Literal(False)
        if self.match([tokens.TRUE]):
            return trees.expr.Literal(True)
        if self.match([tokens.NULL]):
            return trees.expr.Literal(None)
        if self.match([tokens.NUMBER, tokens.STRING]):
            return trees.expr.Literal(self.previous().literal)
        elif self.match([tokens.IDENTIFIER]):
            return trees.expr.Variable(self.previous())
        if self.match([tokens.LEFT_PAREN]):
            expr = self.expression()
            self.consume([tokens.RIGHT_PAREN], "Expect ')' after expression.")
            return trees.expr.Grouping(expr)
        raise self.error(self.peek(), f"Unexpected token {self.peek()}")
    
    def match(self, expected: list) -> bool:
        if self.peek().type in expected:
            self.advance()
            return True
        return False
    
    def check(self, expected: list) -> bool:
        if self.at_end():
            return False
        if self.peek().type in expected:
            return True
        return False
    
    def consume(self, expected: list, message: str) -> None:
        if self.check(expected):
            return self.advance()
        raise self.error(self.peek(), message)
    
    def synchronize(self) -> None:
        self.advance()

        while not self.at_end():
            if self.peek().type == tokens.SEMI_COLON:
                return
            if self.peek().type == tokens.CLASS:
                return
            if self.peek().type == tokens.FUN:
                return
            if self.peek().type == tokens.SET:
                return
            if self.peek().type == tokens.FOR:
                return
            if self.peek().type == tokens.IF:
                return
            if self.peek().type == tokens.WHILE:
                return
            if self.peek().type == tokens.OUTPUT:
                return
            if self.peek().type == tokens.RETURN:
                return
            self.advance()
    
    def advance(self) -> token.Token:
        self.current += 1
        return self.previous()
    
    def peek(self) -> token.Token:
        return self.tokens[self.current]
    
    def previous(self) -> token.Token:
        return self.tokens[self.current - 1]

    def at_end(self) -> bool:
        return self.peek().type == tokens.EOF
    
    def error(self, token: token.Token, message: str) -> None:
        oof.error(token, message)
        return errors.ParseError(token, message)